// Generated by dts-bundle v0.7.3

declare module 'slate' {
    import Block from 'slate/models/block';
    import Changes from 'slate/changes';
    import Character from 'slate/models/character';
    import Data from 'slate/models/data';
    import Document from 'slate/models/document';
    import History from 'slate/models/history';
    import Inline from 'slate/models/inline';
    import Leaf from 'slate/models/leaf';
    import Mark from 'slate/models/mark';
    import Node from 'slate/models/node';
    import Operation from 'slate/models/operation';
    import Operations from 'slate/operations';
    import Range from 'slate/models/range';
    import Schema from 'slate/models/schema';
    import Stack from 'slate/models/stack';
    import Text from 'slate/models/text';
    import Value from 'slate/models/value';
    import { resetKeyGenerator, setKeyGenerator } from 'slate/utils/generate-key';
    /**
      * Export.
      *
      * @type {Object}
      */
    export { Block, Changes, Character, Data, Document, History, Inline, Leaf, Mark, Node, Operation, Operations, Range, Schema, Stack, Text, Value, resetKeyGenerator, setKeyGenerator };
    const _default: {
        Block: any;
        Changes: any;
        Character: any;
        Data: any;
        Document: any;
        History: any;
        Inline: any;
        Leaf: any;
        Mark: any;
        Node: any;
        Operation: any;
        Operations: any;
        Range: any;
        Schema: any;
        Stack: any;
        Text: any;
        Value: any;
        resetKeyGenerator: any;
        setKeyGenerator: any;
    };
    export default _default;
}

declare module 'slate/models/block' {
    /**
        * Prevent circular dependencies.
        */
    // import './document';
    const Block_base: any;
    /**
        * Block.
        *
        * @type {Block}
        */
    class Block extends Block_base {
            /**
                * Create a new `Block` from `attrs`.
                *
                * @param {Object|String|Block} attrs
                * @return {Block}
                */
            static create(attrs?: {}): any;
            /**
                * Create a list of `Blocks` from `attrs`.
                *
                * @param {Array<Block|Object>|List<Block|Object>} attrs
                * @return {List<Block>}
                */
            static createList(attrs?: any[]): any;
            /**
                * Create a `Block` from a JSON `object`.
                *
                * @param {Object|Block} object
                * @return {Block}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Block.fromJSON;
            /**
                * Check if `any` is a `Block`.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isBlock(any: any): boolean;
            /**
                * Check if `any` is a block list.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isBlockList(any: any): any;
            /**
                * Object.
                *
                * @return {String}
                */
            readonly object: string;
            readonly kind: string;
            /**
                * Check if the block is empty.
                *
                * @return {Boolean}
                */
            readonly isEmpty: boolean;
            /**
                * Get the concatenated text of all the block's children.
                *
                * @return {String}
                */
            readonly text: any;
            /**
                * Return a JSON representation of the block.
                *
                * @param {Object} options
                * @return {Object}
                */
            toJSON(options?: {}): {
                    object: string;
                    type: any;
                    isVoid: any;
                    data: any;
                    nodes: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(options: any): {
                    object: string;
                    type: any;
                    isVoid: any;
                    data: any;
                    nodes: any;
            };
    }
    export default Block;
}

declare module 'slate/changes' {
    const _default: any;
    export default _default;
}

declare module 'slate/models/character' {
    const Character_base: any;
    /**
        * Character.
        *
        * @type {Character}
        */
    class Character extends Character_base {
            /**
                * Create a `Character` with `attrs`.
                *
                * @param {Object|String|Character} attrs
                * @return {Character}
                */
            static create(attrs?: {}): any;
            /**
                * Create a list of `Characters` from `elements`.
                *
                * @param {String|Array<Object|Character|String>|List<Object|Character|String>} elements
                * @return {List<Character>}
                */
            static createList(elements?: any[]): any;
            /**
                * Create a `Character` from a JSON `object`.
                *
                * @param {Object} object
                * @return {Character}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Character.fromJSON;
            /**
                * Check if `any` is a `Character`.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isCharacter(any: any): boolean;
            /**
                * Check if `any` is a character list.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isCharacterList(any: any): any;
            /**
                * Object.
                *
                * @return {String}
                */
            readonly object: string;
            readonly kind: string;
            /**
                * Return a JSON representation of the character.
                *
                * @return {Object}
                */
            toJSON(): {
                    object: string;
                    text: any;
                    marks: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(): {
                    object: string;
                    text: any;
                    marks: any;
            };
    }
    export default Character;
}

declare module 'slate/models/data' {
    /**
        * Data.
        *
        * This isn't an immutable record, it's just a thin wrapper around `Map` so that
        * we can allow for more convenient creation.
        *
        * @type {Object}
        */
    class Data {
            /**
                * Create a new `Data` with `attrs`.
                *
                * @param {Object|Data|Map} attrs
                * @return {Data} data
                */
            static create(attrs?: {}): any;
            /**
                * Create a `Data` from a JSON `object`.
                *
                * @param {Object} object
                * @return {Data}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Data.fromJSON;
    }
    export default Data;
}

declare module 'slate/models/document' {
    /**
        * Prevent circular dependencies.
        */
    // import './block';
    // import './inline';
    const Document_base: any;
    /**
        * Document.
        *
        * @type {Document}
        */
    class Document extends Document_base {
            /**
                * Create a new `Document` with `attrs`.
                *
                * @param {Object|Array|List|Text} attrs
                * @return {Document}
                */
            static create(attrs?: {}): any;
            /**
                * Create a `Document` from a JSON `object`.
                *
                * @param {Object|Document} object
                * @return {Document}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Document.fromJSON;
            /**
                * Check if `any` is a `Document`.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isDocument(any: any): boolean;
            /**
                * Object.
                *
                * @return {String}
                */
            readonly object: string;
            readonly kind: string;
            /**
                * Check if the document is empty.
                *
                * @return {Boolean}
                */
            readonly isEmpty: boolean;
            /**
                * Get the concatenated text of all the document's children.
                *
                * @return {String}
                */
            readonly text: any;
            /**
                * Return a JSON representation of the document.
                *
                * @param {Object} options
                * @return {Object}
                */
            toJSON(options?: {}): {
                    object: string;
                    data: any;
                    nodes: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(options: any): {
                    object: string;
                    data: any;
                    nodes: any;
            };
    }
    export default Document;
}

declare module 'slate/models/history' {
    const History_base: any;
    /**
        * History.
        *
        * @type {History}
        */
    class History extends History_base {
            /**
                * Create a new `History` with `attrs`.
                *
                * @param {Object|History} attrs
                * @return {History}
                */
            static create(attrs?: {}): any;
            /**
                * Create a `History` from a JSON `object`.
                *
                * @param {Object} object
                * @return {History}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof History.fromJSON;
            /**
                * Check if `any` is a `History`.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isHistory(any: any): boolean;
            /**
                * Object.
                *
                * @return {String}
                */
            readonly object: string;
            readonly kind: string;
            /**
                * Save an `operation` into the history.
                *
                * @param {Object} operation
                * @param {Object} options
                * @return {History}
                */
            save(operation: any, options?: {}): this;
            /**
                * Return a JSON representation of the history.
                *
                * @return {Object}
                */
            toJSON(): {
                    object: string;
                    redos: any;
                    undos: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(): {
                    object: string;
                    redos: any;
                    undos: any;
            };
    }
    export default History;
}

declare module 'slate/models/inline' {
    /**
        * Prevent circular dependencies.
        */
    // import './document';
    const Inline_base: any;
    /**
        * Inline.
        *
        * @type {Inline}
        */
    class Inline extends Inline_base {
            /**
                * Create a new `Inline` with `attrs`.
                *
                * @param {Object|String|Inline} attrs
                * @return {Inline}
                */
            static create(attrs?: {}): any;
            /**
                * Create a list of `Inlines` from an array.
                *
                * @param {Array<Inline|Object>|List<Inline|Object>} elements
                * @return {List<Inline>}
                */
            static createList(elements?: any[]): any;
            /**
                * Create a `Inline` from a JSON `object`.
                *
                * @param {Object|Inline} object
                * @return {Inline}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Inline.fromJSON;
            /**
                * Check if `any` is a `Inline`.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isInline(any: any): boolean;
            /**
                * Check if `any` is a list of inlines.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isInlineList(any: any): any;
            /**
                * Object.
                *
                * @return {String}
                */
            readonly object: string;
            readonly kind: string;
            /**
                * Check if the inline is empty.
                *
                * @return {Boolean}
                */
            readonly isEmpty: boolean;
            /**
                * Get the concatenated text of all the inline's children.
                *
                * @return {String}
                */
            readonly text: any;
            /**
                * Return a JSON representation of the inline.
                *
                * @param {Object} options
                * @return {Object}
                */
            toJSON(options?: {}): {
                    object: string;
                    type: any;
                    isVoid: any;
                    data: any;
                    nodes: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(options: any): {
                    object: string;
                    type: any;
                    isVoid: any;
                    data: any;
                    nodes: any;
            };
    }
    export default Inline;
}

declare module 'slate/models/leaf' {
    const Leaf_base: any;
    /**
        * Leaf.
        *
        * @type {Leaf}
        */
    class Leaf extends Leaf_base {
            /**
                * Create a new `Leaf` with `attrs`.
                *
                * @param {Object|Leaf} attrs
                * @return {Leaf}
                */
            static create(attrs?: {}): any;
            /**
                * Create a `Leaf` list from `attrs`.
                *
                * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs
                * @return {List<Leaf>}
                */
            static createList(attrs?: any[]): any;
            /**
                * Create a `Leaf` from a JSON `object`.
                *
                * @param {Object} object
                * @return {Leaf}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Leaf.fromJSON;
            /**
                * Check if `any` is a `Leaf`.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isLeaf(any: any): boolean;
            /**
                * Check if `any` is a list of leaves.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isLeafList(any: any): any;
            /**
                * Object.
                *
                * @return {String}
                */
            readonly object: string;
            readonly kind: string;
            /**
                * Return leaf as a list of characters
                *
                * @return {List<Character>}
                */
            getCharacters(): any;
            /**
                * Return a JSON representation of the leaf.
                *
                * @return {Object}
                */
            toJSON(): {
                    object: string;
                    text: any;
                    marks: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(): {
                    object: string;
                    text: any;
                    marks: any;
            };
    }
    export default Leaf;
}

declare module 'slate/models/mark' {
    const Mark_base: any;
    /**
        * Mark.
        *
        * @type {Mark}
        */
    class Mark extends Mark_base {
            /**
                * Create a new `Mark` with `attrs`.
                *
                * @param {Object|Mark} attrs
                * @return {Mark}
                */
            static create(attrs?: {}): any;
            /**
                * Create a set of marks.
                *
                * @param {Array<Object|Mark>} elements
                * @return {Set<Mark>}
                */
            static createSet(elements: any): any;
            /**
                * Create a dictionary of settable mark properties from `attrs`.
                *
                * @param {Object|String|Mark} attrs
                * @return {Object}
                */
            static createProperties(attrs?: {}): {} | {
                    data: any;
                    type: any;
            } | {
                    type: string;
            };
            /**
                * Create a `Mark` from a JSON `object`.
                *
                * @param {Object} object
                * @return {Mark}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Mark.fromJSON;
            /**
                * Check if `any` is a `Mark`.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isMark(any: any): boolean;
            /**
                * Check if `any` is a set of marks.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isMarkSet(any: any): any;
            /**
                * Object.
                */
            readonly object: string;
            readonly kind: string;
            /**
                * Get the component for the node from a `schema`.
                *
                * @param {Schema} schema
                * @return {Component|Void}
                */
            getComponent(schema: any): any;
            /**
                * Return a JSON representation of the mark.
                *
                * @return {Object}
                */
            toJSON(): {
                    object: string;
                    type: any;
                    data: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(): {
                    object: string;
                    type: any;
                    data: any;
            };
    }
    export default Mark;
}

declare module 'slate/models/node' {
    /**
        * Node.
        *
        * And interface that `Document`, `Block` and `Inline` all implement, to make
        * working with the recursive node tree easier.
        *
        * @type {Node}
        */
    class Node {
            /**
                * Create a new `Node` with `attrs`.
                *
                * @param {Object|Node} attrs
                * @return {Node}
                */
            static create(attrs?: {}): any;
            /**
                * Create a list of `Nodes` from an array.
                *
                * @param {Array<Object|Node>} elements
                * @return {List<Node>}
                */
            static createList(elements?: any[]): any;
            /**
                * Create a dictionary of settable node properties from `attrs`.
                *
                * @param {Object|String|Node} attrs
                * @return {Object}
                */
            static createProperties(attrs?: {}): {} | {
                    data: any;
                    isVoid: any;
                    type: any;
            } | {
                    type: string;
            };
            /**
                * Create a `Node` from a JSON `value`.
                *
                * @param {Object} value
                * @return {Node}
                */
            static fromJSON(value: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Node.fromJSON;
            /**
                * Check if `any` is a `Node`.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isNode(any: any): any;
            /**
                * Check if `any` is a list of nodes.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isNodeList(any: any): any;
            /**
                * True if the node has both descendants in that order, false otherwise. The
                * order is depth-first, post-order.
                *
                * @param {String} first
                * @param {String} second
                * @return {Boolean}
                */
            areDescendantsSorted(first: any, second: any): boolean;
            /**
                * Assert that a node has a child by `key` and return it.
                *
                * @param {String} key
                * @return {Node}
                */
            assertChild(key: any): any;
            /**
                * Assert that a node has a descendant by `key` and return it.
                *
                * @param {String} key
                * @return {Node}
                */
            assertDescendant(key: any): any;
            /**
                * Assert that a node's tree has a node by `key` and return it.
                *
                * @param {String} key
                * @return {Node}
                */
            assertNode(key: any): any;
            /**
                * Assert that a node exists at `path` and return it.
                *
                * @param {Array} path
                * @return {Node}
                */
            assertPath(path: any): this;
            /**
                * Recursively filter all descendant nodes with `iterator`.
                *
                * @param {Function} iterator
                * @return {List<Node>}
                */
            filterDescendants(iterator: any): any;
            /**
                * Recursively find all descendant nodes by `iterator`.
                *
                * @param {Function} iterator
                * @return {Node|Null}
                */
            findDescendant(iterator: any): any;
            /**
                * Recursively iterate over all descendant nodes with `iterator`. If the
                * iterator returns false it will break the loop.
                *
                * @param {Function} iterator
                */
            forEachDescendant(iterator: any): any;
            /**
                * Get the path of ancestors of a descendant node by `key`.
                *
                * @param {String|Node} key
                * @return {List<Node>|Null}
                */
            getAncestors(key: any): any;
            /**
                * Get the leaf block descendants of the node.
                *
                * @return {List<Node>}
                */
            getBlocks(): any;
            /**
                * Get the leaf block descendants of the node.
                *
                * @return {List<Node>}
                */
            getBlocksAsArray(): any;
            /**
                * Get the leaf block descendants in a `range`.
                *
                * @param {Range} range
                * @return {List<Node>}
                */
            getBlocksAtRange(range: any): any;
            /**
                * Get the leaf block descendants in a `range` as an array
                *
                * @param {Range} range
                * @return {Array}
                */
            getBlocksAtRangeAsArray(range: any): any;
            /**
                * Get all of the leaf blocks that match a `type`.
                *
                * @param {String} type
                * @return {List<Node>}
                */
            getBlocksByType(type: any): any;
            /**
                * Get all of the leaf blocks that match a `type` as an array
                *
                * @param {String} type
                * @return {Array}
                */
            getBlocksByTypeAsArray(type: any): any;
            /**
                * Get all of the characters for every text node.
                *
                * @return {List<Character>}
                */
            getCharacters(): any;
            /**
                * Get all of the characters for every text node as an array
                *
                * @return {Array}
                */
            getCharactersAsArray(): any;
            /**
                * Get a list of the characters in a `range`.
                *
                * @param {Range} range
                * @return {List<Character>}
                */
            getCharactersAtRange(range: any): any;
            /**
                * Get a list of the characters in a `range` as an array.
                *
                * @param {Range} range
                * @return {Array}
                */
            getCharactersAtRangeAsArray(range: any): any;
            /**
                * Get a child node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getChild(key: any): any;
            /**
                * Get closest parent of node by `key` that matches `iterator`.
                *
                * @param {String} key
                * @param {Function} iterator
                * @return {Node|Null}
                */
            getClosest(key: any, iterator: any): any;
            /**
                * Get the closest block parent of a `node`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getClosestBlock(key: any): any;
            /**
                * Get the closest inline parent of a `node`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getClosestInline(key: any): any;
            /**
                * Get the closest void parent of a `node`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getClosestVoid(key: any): any;
            /**
                * Get the common ancestor of nodes `one` and `two` by keys.
                *
                * @param {String} one
                * @param {String} two
                * @return {Node}
                */
            getCommonAncestor(one: any, two: any): any;
            /**
                * Get the decorations for the node from a `stack`.
                *
                * @param {Stack} stack
                * @return {List}
                */
            getDecorations(stack: any): any;
            /**
                * Get the depth of a child node by `key`, with optional `startAt`.
                *
                * @param {String} key
                * @param {Number} startAt (optional)
                * @return {Number} depth
                */
            getDepth(key: any, startAt?: number): any;
            /**
                * Get a descendant node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getDescendant(key: any): any;
            /**
                * Get a descendant by `path`.
                *
                * @param {Array} path
                * @return {Node|Null}
                */
            getDescendantAtPath(path: any): this;
            /**
                * Get the first child text node.
                *
                * @return {Node|Null}
                */
            getFirstText(): any;
            /**
                * Get a fragment of the node at a `range`.
                *
                * @param {Range} range
                * @return {Document}
                */
            getFragmentAtRange(range: any): any;
            /**
                * Get the furthest parent of a node by `key` that matches an `iterator`.
                *
                * @param {String} key
                * @param {Function} iterator
                * @return {Node|Null}
                */
            getFurthest(key: any, iterator: any): any;
            /**
                * Get the furthest block parent of a node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getFurthestBlock(key: any): any;
            /**
                * Get the furthest inline parent of a node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getFurthestInline(key: any): any;
            /**
                * Get the furthest ancestor of a node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getFurthestAncestor(key: any): any;
            /**
                * Get the furthest ancestor of a node by `key` that has only one child.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getFurthestOnlyChildAncestor(key: any): any;
            /**
                * Get the closest inline nodes for each text node in the node.
                *
                * @return {List<Node>}
                */
            getInlines(): any;
            /**
                * Get the closest inline nodes for each text node in the node, as an array.
                *
                * @return {List<Node>}
                */
            getInlinesAsArray(): any[];
            /**
                * Get the closest inline nodes for each text node in a `range`.
                *
                * @param {Range} range
                * @return {List<Node>}
                */
            getInlinesAtRange(range: any): any;
            /**
                * Get the closest inline nodes for each text node in a `range` as an array.
                *
                * @param {Range} range
                * @return {Array}
                */
            getInlinesAtRangeAsArray(range: any): any[];
            /**
                * Get all of the leaf inline nodes that match a `type`.
                *
                * @param {String} type
                * @return {List<Node>}
                */
            getInlinesByType(type: any): any;
            /**
                * Get all of the leaf inline nodes that match a `type` as an array.
                *
                * @param {String} type
                * @return {Array}
                */
            getInlinesByTypeAsArray(type: any): any;
            /**
                * Return a set of all keys in the node as an array.
                *
                * @return {Array<String>}
                */
            getKeysAsArray(): any[];
            /**
                * Return a set of all keys in the node.
                *
                * @return {Set<String>}
                */
            getKeys(): any;
            /**
                * Get the last child text node.
                *
                * @return {Node|Null}
                */
            getLastText(): any;
            /**
                * Get all of the marks for all of the characters of every text node.
                *
                * @return {Set<Mark>}
                */
            getMarks(): any;
            /**
                * Get all of the marks for all of the characters of every text node.
                *
                * @return {OrderedSet<Mark>}
                */
            getOrderedMarks(): any;
            /**
                * Get all of the marks as an array.
                *
                * @return {Array}
                */
            getMarksAsArray(): any;
            /**
                * Get a set of the marks in a `range`.
                *
                * @param {Range} range
                * @return {Set<Mark>}
                */
            getMarksAtRange(range: any): any;
            /**
                * Get a set of the marks in a `range`.
                *
                * @param {Range} range
                * @return {OrderedSet<Mark>}
                */
            getOrderedMarksAtRange(range: any): any;
            /**
                * Get a set of the active marks in a `range`.
                *
                * @param {Range} range
                * @return {Set<Mark>}
                */
            getActiveMarksAtRange(range: any): any;
            /**
                * Get a set of the marks in a `range`, by unioning.
                *
                * @param {Range} range
                * @return {Array}
                */
            getMarksAtRangeAsArray(range: any): any;
            /**
                * Get a set of marks in a `range`, by intersecting.
                *
                * @param {Range} range
                * @return {Array}
                */
            getActiveMarksAtRangeAsArray(range: any): any;
            /**
                * Get all of the marks that match a `type`.
                *
                * @param {String} type
                * @return {Set<Mark>}
                */
            getMarksByType(type: any): any;
            /**
                * Get all of the marks that match a `type`.
                *
                * @param {String} type
                * @return {OrderedSet<Mark>}
                */
            getOrderedMarksByType(type: any): any;
            /**
                * Get all of the marks that match a `type` as an array.
                *
                * @param {String} type
                * @return {Array}
                */
            getMarksByTypeAsArray(type: any): any;
            /**
                * Get the block node before a descendant text node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getNextBlock(key: any): any;
            /**
                * Get the node after a descendant by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getNextSibling(key: any): any;
            /**
                * Get the text node after a descendant text node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getNextText(key: any): any;
            /**
                * Get a node in the tree by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getNode(key: any): any;
            /**
                * Get a node in the tree by `path`.
                *
                * @param {Array} path
                * @return {Node|Null}
                */
            getNodeAtPath(path: any): this;
            /**
                * Get the offset for a descendant text node by `key`.
                *
                * @param {String} key
                * @return {Number}
                */
            getOffset(key: any): any;
            /**
                * Get the offset from a `range`.
                *
                * @param {Range} range
                * @return {Number}
                */
            getOffsetAtRange(range: any): any;
            /**
                * Get the parent of a child node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getParent(key: any): any;
            /**
                * Get the path of a descendant node by `key`.
                *
                * @param {String|Node} key
                * @return {Array}
                */
            getPath(key: any): any[];
            /**
                * Get the placeholder for the node from a `schema`.
                *
                * @param {Schema} schema
                * @return {Component|Void}
                */
            getPlaceholder(schema: any): any;
            /**
                * Get the block node before a descendant text node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getPreviousBlock(key: any): any;
            /**
                * Get the node before a descendant node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getPreviousSibling(key: any): any;
            /**
                * Get the text node before a descendant text node by `key`.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getPreviousText(key: any): any;
            /**
                * Get the indexes of the selection for a `range`, given an extra flag for
                * whether the node `isSelected`, to determine whether not finding matches
                * means everything is selected or nothing is.
                *
                * @param {Range} range
                * @param {Boolean} isSelected
                * @return {Object|Null}
                */
            getSelectionIndexes(range: any, isSelected?: boolean): {
                    start: any;
                    end: any;
            };
            /**
                * Get the concatenated text string of all child nodes.
                *
                * @return {String}
                */
            getText(): any;
            /**
                * Get the descendent text node at an `offset`.
                *
                * @param {String} offset
                * @return {Node|Null}
                */
            getTextAtOffset(offset: any): any;
            /**
                * Get the direction of the node's text.
                *
                * @return {String}
                */
            getTextDirection(): any;
            /**
                * Recursively get all of the child text nodes in order of appearance.
                *
                * @return {List<Node>}
                */
            getTexts(): any;
            /**
                * Recursively get all the leaf text nodes in order of appearance, as array.
                *
                * @return {List<Node>}
                */
            getTextsAsArray(): any[];
            /**
                * Get all of the text nodes in a `range`.
                *
                * @param {Range} range
                * @return {List<Node>}
                */
            getTextsAtRange(range: any): any;
            /**
                * Get all of the text nodes in a `range` as an array.
                *
                * @param {Range} range
                * @return {Array}
                */
            getTextsAtRangeAsArray(range: any): any[];
            /**
                * Check if a child node exists by `key`.
                *
                * @param {String} key
                * @return {Boolean}
                */
            hasChild(key: any): boolean;
            /**
                * Recursively check if a child node exists by `key`.
                *
                * @param {String} key
                * @return {Boolean}
                */
            hasDescendant(key: any): boolean;
            /**
                * Recursively check if a node exists by `key`.
                *
                * @param {String} key
                * @return {Boolean}
                */
            hasNode(key: any): boolean;
            /**
                * Check if a node has a void parent by `key`.
                *
                * @param {String} key
                * @return {Boolean}
                */
            hasVoidParent(key: any): boolean;
            /**
                * Insert a `node` at `index`.
                *
                * @param {Number} index
                * @param {Node} node
                * @return {Node}
                */
            insertNode(index: any, node: any): any;
            /**
                * Check whether the node is in a `range`.
                *
                * @param {Range} range
                * @return {Boolean}
                */
            isInRange(range: any): boolean;
            /**
                * Check whether the node is a leaf block.
                *
                * @return {Boolean}
                */
            isLeafBlock(): any;
            /**
                * Check whether the node is a leaf inline.
                *
                * @return {Boolean}
                */
            isLeafInline(): any;
            /**
                * Merge a children node `first` with another children node `second`.
                * `first` and `second` will be concatenated in that order.
                * `first` and `second` must be two Nodes or two Text.
                *
                * @param {Node} first
                * @param {Node} second
                * @return {Node}
                */
            mergeNode(withIndex: any, index: any): this;
            /**
                * Map all child nodes, updating them in their parents. This method is
                * optimized to not return a new node if no changes are made.
                *
                * @param {Function} iterator
                * @return {Node}
                */
            mapChildren(iterator: any): any;
            /**
                * Map all descendant nodes, updating them in their parents. This method is
                * optimized to not return a new node if no changes are made.
                *
                * @param {Function} iterator
                * @return {Node}
                */
            mapDescendants(iterator: any): any;
            /**
                * Regenerate the node's key.
                *
                * @return {Node}
                */
            regenerateKey(): any;
            /**
                * Remove a `node` from the children node map.
                *
                * @param {String} key
                * @return {Node}
                */
            removeDescendant(key: any): this;
            /**
                * Remove a node at `index`.
                *
                * @param {Number} index
                * @return {Node}
                */
            removeNode(index: any): any;
            /**
                * Split a child node by `index` at `position`.
                *
                * @param {Number} index
                * @param {Number} position
                * @return {Node}
                */
            splitNode(index: any, position: any): this;
            /**
                * Set a new value for a child node by `key`.
                *
                * @param {Node} node
                * @return {Node}
                */
            updateNode(node: any): any;
            /**
                * Validate the node against a `schema`.
                *
                * @param {Schema} schema
                * @return {Function|Null}
                */
            validate(schema: any): any;
    }
    export default Node;
}

declare module 'slate/models/operation' {
    const Operation_base: any;
    /**
        * Operation.
        *
        * @type {Operation}
        */
    class Operation extends Operation_base {
            /**
                * Create a new `Operation` with `attrs`.
                *
                * @param {Object|Array|List|String|Operation} attrs
                * @return {Operation}
                */
            static create(attrs?: {}): any;
            /**
                * Create a list of `Operations` from `elements`.
                *
                * @param {Array<Operation|Object>|List<Operation|Object>} elements
                * @return {List<Operation>}
                */
            static createList(elements?: any[]): any;
            /**
                * Create a `Operation` from a JSON `object`.
                *
                * @param {Object|Operation} object
                * @return {Operation}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Operation.fromJSON;
            /**
                * Check if `any` is a `Operation`.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isOperation(any: any): boolean;
            /**
                * Check if `any` is a list of operations.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isOperationList(any: any): any;
            /**
                * Object.
                *
                * @return {String}
                */
            readonly object: string;
            readonly kind: string;
            /**
                * Return a JSON representation of the operation.
                *
                * @param {Object} options
                * @return {Object}
                */
            toJSON(options?: {}): {
                    object: string;
                    type: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(options: any): {
                    object: string;
                    type: any;
            };
    }
    export default Operation;
}

declare module 'slate/operations' {
    const _default: {
        apply: any;
        invert: any;
    };
    export default _default;
}

declare module 'slate/models/range' {
    const Range_base: any;
    /**
        * Range.
        *
        * @type {Range}
        */
    class Range extends Range_base {
            /**
                * Create a new `Range` with `attrs`.
                *
                * @param {Object|Range} attrs
                * @return {Range}
                */
            static create(attrs?: {}): any;
            /**
                * Create a list of `Ranges` from `elements`.
                *
                * @param {Array<Range|Object>|List<Range|Object>} elements
                * @return {List<Range>}
                */
            static createList(elements?: any[]): any;
            /**
                * Create a dictionary of settable range properties from `attrs`.
                *
                * @param {Object|String|Range} attrs
                * @return {Object}
                */
            static createProperties(attrs?: {}): {} | {
                    anchorKey: any;
                    anchorOffset: any;
                    focusKey: any;
                    focusOffset: any;
                    isBackward: any;
                    isFocused: any;
                    marks: any;
            };
            /**
                * Create a `Range` from a JSON `object`.
                *
                * @param {Object} object
                * @return {Range}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Range.fromJSON;
            /**
                * Check if an `obj` is a `Range`.
                *
                * @param {Any} obj
                * @return {Boolean}
                */
            static isRange(obj: any): boolean;
            /**
                * Object.
                *
                * @return {String}
                */
            readonly object: string;
            readonly kind: string;
            /**
                * Check whether the range is blurred.
                *
                * @return {Boolean}
                */
            readonly isBlurred: boolean;
            /**
                * Check whether the range is collapsed.
                *
                * @return {Boolean}
                */
            readonly isCollapsed: boolean;
            /**
                * Check whether the range is expanded.
                *
                * @return {Boolean}
                */
            readonly isExpanded: boolean;
            /**
                * Check whether the range is forward.
                *
                * @return {Boolean}
                */
            readonly isForward: boolean;
            /**
                * Check whether the range's keys are set.
                *
                * @return {Boolean}
                */
            readonly isSet: boolean;
            /**
                * Check whether the range's keys are not set.
                *
                * @return {Boolean}
                */
            readonly isUnset: boolean;
            /**
                * Get the start key.
                *
                * @return {String}
                */
            readonly startKey: any;
            /**
                * Get the start offset.
                *
                * @return {String}
                */
            readonly startOffset: any;
            /**
                * Get the end key.
                *
                * @return {String}
                */
            readonly endKey: any;
            /**
                * Get the end offset.
                *
                * @return {String}
                */
            readonly endOffset: any;
            /**
                * Check whether anchor point of the range is at the start of a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            hasAnchorAtStartOf(node: any): boolean;
            /**
                * Check whether anchor point of the range is at the end of a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            hasAnchorAtEndOf(node: any): boolean;
            /**
                * Check whether the anchor edge of a range is in a `node` and at an
                * offset between `start` and `end`.
                *
                * @param {Node} node
                * @param {Number} start
                * @param {Number} end
                * @return {Boolean}
                */
            hasAnchorBetween(node: any, start: any, end: any): any;
            /**
                * Check whether the anchor edge of a range is in a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            hasAnchorIn(node: any): any;
            /**
                * Check whether focus point of the range is at the end of a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            hasFocusAtEndOf(node: any): boolean;
            /**
                * Check whether focus point of the range is at the start of a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            hasFocusAtStartOf(node: any): boolean;
            /**
                * Check whether the focus edge of a range is in a `node` and at an
                * offset between `start` and `end`.
                *
                * @param {Node} node
                * @param {Number} start
                * @param {Number} end
                * @return {Boolean}
                */
            hasFocusBetween(node: any, start: any, end: any): any;
            /**
                * Check whether the focus edge of a range is in a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            hasFocusIn(node: any): any;
            /**
                * Check whether the range is at the start of a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            isAtStartOf(node: any): boolean;
            /**
                * Check whether the range is at the end of a `node`.
                *
                * @param {Node} node
                * @return {Boolean}
                */
            isAtEndOf(node: any): boolean;
            /**
                * Focus the range.
                *
                * @return {Range}
                */
            focus(): any;
            /**
                * Blur the range.
                *
                * @return {Range}
                */
            blur(): any;
            /**
                * Unset the range.
                *
                * @return {Range}
                */
            deselect(): any;
            /**
                * Flip the range.
                *
                * @return {Range}
                */
            flip(): any;
            /**
                * Move the anchor offset `n` characters.
                *
                * @param {Number} n (optional)
                * @return {Range}
                */
            moveAnchor(n?: number): any;
            /**
                * Move the anchor offset `n` characters.
                *
                * @param {Number} n (optional)
                * @return {Range}
                */
            moveFocus(n?: number): any;
            /**
                * Move the range's anchor point to a `key` and `offset`.
                *
                * @param {String} key
                * @param {Number} offset
                * @return {Range}
                */
            moveAnchorTo(key: any, offset: any): any;
            /**
                * Move the range's focus point to a `key` and `offset`.
                *
                * @param {String} key
                * @param {Number} offset
                * @return {Range}
                */
            moveFocusTo(key: any, offset: any): any;
            /**
                * Move the range to `anchorOffset`.
                *
                * @param {Number} anchorOffset
                * @return {Range}
                */
            moveAnchorOffsetTo(anchorOffset: any): any;
            /**
                * Move the range to `focusOffset`.
                *
                * @param {Number} focusOffset
                * @return {Range}
                */
            moveFocusOffsetTo(focusOffset: any): any;
            /**
                * Move the range to `anchorOffset` and `focusOffset`.
                *
                * @param {Number} anchorOffset
                * @param {Number} focusOffset (optional)
                * @return {Range}
                */
            moveOffsetsTo(anchorOffset: any, focusOffset?: any): any;
            /**
                * Move the focus point to the anchor point.
                *
                * @return {Range}
                */
            moveToAnchor(): any;
            /**
                * Move the anchor point to the focus point.
                *
                * @return {Range}
                */
            moveToFocus(): any;
            /**
                * Move the range's anchor point to the start of a `node`.
                *
                * @param {Node} node
                * @return {Range}
                */
            moveAnchorToStartOf(node: any): any;
            /**
                * Move the range's anchor point to the end of a `node`.
                *
                * @param {Node} node
                * @return {Range}
                */
            moveAnchorToEndOf(node: any): any;
            /**
                * Move the range's focus point to the start of a `node`.
                *
                * @param {Node} node
                * @return {Range}
                */
            moveFocusToStartOf(node: any): any;
            /**
                * Move the range's focus point to the end of a `node`.
                *
                * @param {Node} node
                * @return {Range}
                */
            moveFocusToEndOf(node: any): any;
            /**
                * Move to the entire range of `start` and `end` nodes.
                *
                * @param {Node} start
                * @param {Node} end (optional)
                * @return {Range}
                */
            moveToRangeOf(start: any, end?: any): any;
            /**
                * Normalize the range, relative to a `node`, ensuring that the anchor
                * and focus nodes of the range always refer to leaf text nodes.
                *
                * @param {Node} node
                * @return {Range}
                */
            normalize(node: any): any;
            /**
                * Return a JSON representation of the range.
                *
                * @return {Object}
                */
            toJSON(): {
                    object: string;
                    anchorKey: any;
                    anchorOffset: any;
                    focusKey: any;
                    focusOffset: any;
                    isBackward: any;
                    isFocused: any;
                    marks: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(): {
                    object: string;
                    anchorKey: any;
                    anchorOffset: any;
                    focusKey: any;
                    focusOffset: any;
                    isBackward: any;
                    isFocused: any;
                    marks: any;
            };
    }
    export default Range;
}

declare module 'slate/models/schema' {
    const Schema_base: any;
    /**
        * Schema.
        *
        * @type {Schema}
        */
    class Schema extends Schema_base {
            /**
                * Create a new `Schema` with `attrs`.
                *
                * @param {Object|Schema} attrs
                * @return {Schema}
                */
            static create(attrs?: {}): any;
            /**
                * Create a `Schema` from a JSON `object`.
                *
                * @param {Object} object
                * @return {Schema}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Schema.fromJSON;
            /**
                * Check if `any` is a `Schema`.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isSchema(any: any): boolean;
            /**
                * Object.
                *
                * @return {String}
                */
            readonly object: string;
            readonly kind: string;
            /**
                * Get the rule for an `object`.
                *
                * @param {Mixed} object
                * @return {Object}
                */
            getRule(object: any): any;
            /**
                * Get a dictionary of the parent rule validations by child type.
                *
                * @return {Object|Null}
                */
            getParentRules(): {};
            /**
                * Fail validation by returning a normalizing change function.
                *
                * @param {String} reason
                * @param {Object} context
                * @return {Function}
                */
            fail(reason: any, context: any): (change: any) => void;
            /**
                * Normalize an invalid value with `reason` and `context`.
                *
                * @param {Change} change
                * @param {String} reason
                * @param {Mixed} context
                */
            normalize(change: any, reason: any, context: any): any;
            /**
                * Validate a `node` with the schema, returning a function that will fix the
                * invalid node, or void if the node is valid.
                *
                * @param {Node} node
                * @return {Function|Void}
                */
            validateNode(node: any): any;
            /**
                * Return a JSON representation of the schema.
                *
                * @return {Object}
                */
            toJSON(): {
                    object: string;
                    document: any;
                    blocks: any;
                    inlines: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(): {
                    object: string;
                    document: any;
                    blocks: any;
                    inlines: any;
            };
    }
    export default Schema;
}

declare module 'slate/models/stack' {
    const Stack_base: any;
    /**
        * Stack.
        *
        * @type {Stack}
        */
    class Stack extends Stack_base {
            /**
                * Constructor.
                *
                * @param {Object} attrs
                */
            static create(attrs?: {}): any;
            /**
                * Check if `any` is a `Stack`.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isStack(any: any): boolean;
            /**
                * Object.
                *
                * @return {String}
                */
            readonly object: string;
            readonly kind: string;
            /**
                * Get all plugins with `property`.
                *
                * @param {String} property
                * @return {Array}
                */
            getPluginsWith(property: any): any;
            /**
                * Iterate the plugins with `property`, returning the first non-null value.
                *
                * @param {String} property
                * @param {Any} ...args
                */
            find(property: any, ...args: any[]): any;
            /**
                * Iterate the plugins with `property`, returning all the non-null values.
                *
                * @param {String} property
                * @param {Any} ...args
                * @return {Array}
                */
            map(property: any, ...args: any[]): any[];
            /**
                * Iterate the plugins with `property`, breaking on any a non-null values.
                *
                * @param {String} property
                * @param {Any} ...args
                */
            run(property: any, ...args: any[]): void;
            /**
                * Iterate the plugins with `property`, reducing to a set of React children.
                *
                * @param {String} property
                * @param {Object} props
                * @param {Any} ...args
                */
            render(property: any, props: any, ...args: any[]): any;
    }
    export default Stack;
}

declare module 'slate/models/text' {
    const Text_base: any;
    /**
        * Text.
        *
        * @type {Text}
        */
    class Text extends Text_base {
            /**
                * Create a new `Text` with `attrs`.
                *
                * @param {Object|Array|List|String|Text} attrs
                * @return {Text}
                */
            static create(attrs?: string): any;
            /**
                * Create a list of `Texts` from `elements`.
                *
                * @param {Array<Text|Object>|List<Text|Object>} elements
                * @return {List<Text>}
                */
            static createList(elements?: any[]): any;
            /**
                * Create a `Text` from a JSON `object`.
                *
                * @param {Object|Text} object
                * @return {Text}
                */
            static fromJSON(object: any): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Text.fromJSON;
            /**
                * Check if `any` is a `Text`.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isText(any: any): boolean;
            /**
                * Check if `any` is a list of texts.
                *
                * @param {Any} any
                * @return {Boolean}
                */
            static isTextList(any: any): any;
            /**
                * Object.
                *
                * @return {String}
                */
            readonly object: string;
            readonly kind: string;
            /**
                * Is the node empty?
                *
                * @return {Boolean}
                */
            readonly isEmpty: boolean;
            /**
                * Get the concatenated text of the node.
                *
                * @return {String}
                */
            readonly text: any;
            /**
                * Add a `mark` at `index` and `length`.
                *
                * @param {Number} index
                * @param {Number} length
                * @param {Mark} mark
                * @return {Text}
                */
            addMark(index: any, length: any, mark: any): any;
            /**
                * Add a `set` of marks at `index` and `length`.
                *
                * @param {Number} index
                * @param {Number} length
                * @param {Set<Mark>} set
                * @return {Text}
                */
            addMarks(index: any, length: any, set: any): any;
            /**
                * Derive a set of decorated characters with `decorations`.
                *
                * @param {List<Decoration>} decorations
                * @return {List<Character>}
                */
            getDecoratedCharacters(decorations: any): any;
            /**
                * Get the decorations for the node from a `schema`.
                *
                * @param {Schema} schema
                * @return {Array}
                */
            getDecorations(schema: any): any;
            /**
                * Derive the leaves for a list of `characters`.
                *
                * @param {Array|Void} decorations (optional)
                * @return {List<Leaf>}
                */
            getLeaves(decorations?: any[]): any[];
            /**
                * Get all of the marks on the text.
                *
                * @return {OrderedSet<Mark>}
                */
            getMarks(): any;
            /**
                * Get all of the marks on the text as an array
                *
                * @return {Array}
                */
            getMarksAsArray(): any;
            /**
                * Get the marks on the text at `index`.
                *
                * @param {Number} index
                * @return {Set<Mark>}
                */
            getMarksAtIndex(index: any): any;
            /**
                * Get a node by `key`, to parallel other nodes.
                *
                * @param {String} key
                * @return {Node|Null}
                */
            getNode(key: any): this;
            /**
                * Check if the node has a node by `key`, to parallel other nodes.
                *
                * @param {String} key
                * @return {Boolean}
                */
            hasNode(key: any): boolean;
            /**
                * Insert `text` at `index`.
                *
                * @param {Numbder} index
                * @param {String} text
                * @param {String} marks (optional)
                * @return {Text}
                */
            insertText(index: any, text: any, marks: any): any;
            /**
                * Regenerate the node's key.
                *
                * @return {Text}
                */
            regenerateKey(): any;
            /**
                * Remove a `mark` at `index` and `length`.
                *
                * @param {Number} index
                * @param {Number} length
                * @param {Mark} mark
                * @return {Text}
                */
            removeMark(index: any, length: any, mark: any): any;
            /**
                * Remove text from the text node at `index` for `length`.
                *
                * @param {Number} index
                * @param {Number} length
                * @return {Text}
                */
            removeText(index: any, length: any): any;
            /**
                * Return a JSON representation of the text.
                *
                * @param {Object} options
                * @return {Object}
                */
            toJSON(options?: {}): {
                    object: string;
                    leaves: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(options: any): {
                    object: string;
                    leaves: any;
            };
            /**
                * Update a `mark` at `index` and `length` with `properties`.
                *
                * @param {Number} index
                * @param {Number} length
                * @param {Mark} mark
                * @param {Object} properties
                * @return {Text}
                */
            updateMark(index: any, length: any, mark: any, properties: any): any;
            /**
                * Validate the text node against a `schema`.
                *
                * @param {Schema} schema
                * @return {Object|Void}
                */
            validate(schema: any): any;
    }
    export default Text;
}

declare module 'slate/models/value' {
    const Value_base: any;
    /**
        * Value.
        *
        * @type {Value}
        */
    class Value extends Value_base {
            /**
                * Create a new `Value` with `attrs`.
                *
                * @param {Object|Value} attrs
                * @param {Object} options
                * @return {Value}
                */
            static create(attrs?: {}, options?: {}): any;
            /**
                * Create a dictionary of settable value properties from `attrs`.
                *
                * @param {Object|Value} attrs
                * @return {Object}
                */
            static createProperties(attrs?: {}): {} | {
                    data: any;
                    decorations: any;
                    schema: any;
            };
            /**
                * Create a `Value` from a JSON `object`.
                *
                * @param {Object} object
                * @param {Object} options
                *   @property {Boolean} normalize
                *   @property {Array} plugins
                * @return {Value}
                */
            static fromJSON(object: any, options?: {}): any;
            /**
                * Alias `fromJS`.
                */
            static fromJS: typeof Value.fromJSON;
            /**
                * Check if a `value` is a `Value`.
                *
                * @param {Any} value
                * @return {Boolean}
                */
            static isValue(value: any): boolean;
            /**
                * Object.
                *
                * @return {String}
                */
            readonly object: string;
            readonly kind: string;
            /**
                * Are there undoable events?
                *
                * @return {Boolean}
                */
            readonly hasUndos: boolean;
            /**
                * Are there redoable events?
                *
                * @return {Boolean}
                */
            readonly hasRedos: boolean;
            /**
                * Is the current selection blurred?
                *
                * @return {Boolean}
                */
            readonly isBlurred: any;
            /**
                * Is the current selection focused?
                *
                * @return {Boolean}
                */
            readonly isFocused: any;
            /**
                * Is the current selection collapsed?
                *
                * @return {Boolean}
                */
            readonly isCollapsed: any;
            /**
                * Is the current selection expanded?
                *
                * @return {Boolean}
                */
            readonly isExpanded: any;
            /**
                * Is the current selection backward?
                *
                * @return {Boolean} isBackward
                */
            readonly isBackward: any;
            /**
                * Is the current selection forward?
                *
                * @return {Boolean}
                */
            readonly isForward: any;
            /**
                * Get the current start key.
                *
                * @return {String}
                */
            readonly startKey: any;
            /**
                * Get the current end key.
                *
                * @return {String}
                */
            readonly endKey: any;
            /**
                * Get the current start offset.
                *
                * @return {String}
                */
            readonly startOffset: any;
            /**
                * Get the current end offset.
                *
                * @return {String}
                */
            readonly endOffset: any;
            /**
                * Get the current anchor key.
                *
                * @return {String}
                */
            readonly anchorKey: any;
            /**
                * Get the current focus key.
                *
                * @return {String}
                */
            readonly focusKey: any;
            /**
                * Get the current anchor offset.
                *
                * @return {String}
                */
            readonly anchorOffset: any;
            /**
                * Get the current focus offset.
                *
                * @return {String}
                */
            readonly focusOffset: any;
            /**
                * Get the current start text node's closest block parent.
                *
                * @return {Block}
                */
            readonly startBlock: any;
            /**
                * Get the current end text node's closest block parent.
                *
                * @return {Block}
                */
            readonly endBlock: any;
            /**
                * Get the current anchor text node's closest block parent.
                *
                * @return {Block}
                */
            readonly anchorBlock: any;
            /**
                * Get the current focus text node's closest block parent.
                *
                * @return {Block}
                */
            readonly focusBlock: any;
            /**
                * Get the current start text node's closest inline parent.
                *
                * @return {Inline}
                */
            readonly startInline: any;
            /**
                * Get the current end text node's closest inline parent.
                *
                * @return {Inline}
                */
            readonly endInline: any;
            /**
                * Get the current anchor text node's closest inline parent.
                *
                * @return {Inline}
                */
            readonly anchorInline: any;
            /**
                * Get the current focus text node's closest inline parent.
                *
                * @return {Inline}
                */
            readonly focusInline: any;
            /**
                * Get the current start text node.
                *
                * @return {Text}
                */
            readonly startText: any;
            /**
                * Get the current end node.
                *
                * @return {Text}
                */
            readonly endText: any;
            /**
                * Get the current anchor node.
                *
                * @return {Text}
                */
            readonly anchorText: any;
            /**
                * Get the current focus node.
                *
                * @return {Text}
                */
            readonly focusText: any;
            /**
                * Get the next block node.
                *
                * @return {Block}
                */
            readonly nextBlock: any;
            /**
                * Get the previous block node.
                *
                * @return {Block}
                */
            readonly previousBlock: any;
            /**
                * Get the next inline node.
                *
                * @return {Inline}
                */
            readonly nextInline: any;
            /**
                * Get the previous inline node.
                *
                * @return {Inline}
                */
            readonly previousInline: any;
            /**
                * Get the next text node.
                *
                * @return {Text}
                */
            readonly nextText: any;
            /**
                * Get the previous text node.
                *
                * @return {Text}
                */
            readonly previousText: any;
            /**
                * Get the characters in the current selection.
                *
                * @return {List<Character>}
                */
            readonly characters: any;
            /**
                * Get the marks of the current selection.
                *
                * @return {Set<Mark>}
                */
            readonly marks: any;
            /**
                * Get the active marks of the current selection.
                *
                * @return {Set<Mark>}
                */
            readonly activeMarks: any;
            /**
                * Get the block nodes in the current selection.
                *
                * @return {List<Block>}
                */
            readonly blocks: any;
            /**
                * Get the fragment of the current selection.
                *
                * @return {Document}
                */
            readonly fragment: any;
            /**
                * Get the inline nodes in the current selection.
                *
                * @return {List<Inline>}
                */
            readonly inlines: any;
            /**
                * Get the text nodes in the current selection.
                *
                * @return {List<Text>}
                */
            readonly texts: any;
            /**
                * Check whether the selection is empty.
                *
                * @return {Boolean}
                */
            readonly isEmpty: boolean;
            /**
                * Check whether the selection is collapsed in a void node.
                *
                * @return {Boolean}
                */
            readonly isInVoid: any;
            /**
                * Create a new `Change` with the current value as a starting point.
                *
                * @param {Object} attrs
                * @return {Change}
                */
            change(attrs?: {}): any;
            /**
                * Return a JSON representation of the value.
                *
                * @param {Object} options
                * @return {Object}
                */
            toJSON(options?: {}): {
                    object: string;
                    document: any;
            };
            /**
                * Alias `toJS`.
                */
            toJS(options: any): {
                    object: string;
                    document: any;
            };
    }
    export default Value;
}

declare module 'slate/utils/generate-key' {
    /**
        * Generate a key.
        *
        * @return {String}
        */
    function generateKey(): any;
    /**
        * Set a different unique ID generating `function`.
        *
        * @param {Function} func
        */
    function setKeyGenerator(func: any): void;
    /**
        * Reset the key generating function to its initial state.
        */
    function resetKeyGenerator(): void;
    /**
        * Export.
        *
        * @type {Object}
        */
    export { generateKey as default, setKeyGenerator, resetKeyGenerator };
}
